/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const memoize = require("../util/memoize");

const LAZY_TARGET = Symbol("lazy serialization target");
const LAZY_SERIALIZED_VALUE = Symbol("lazy serialization data");

<<<<<<< Updated upstream
=======
/** @typedef {TODO} Context */

/**
 * @template LazyResult
 * @typedef {() => LazyResult | Promise<LazyResult>} InternalLazyFunction
 */

/** @typedef {Record<string, any>} LazyOptions */

/**
 * @template LazyResult
 * @typedef {InternalLazyFunction<LazyResult> & { [LAZY_TARGET]: TODO, [LAZY_SERIALIZED_VALUE]?: TODO, options: LazyOptions }} LazyFunction
 */

>>>>>>> Stashed changes
/**
 * @template DeserializedType
 * @template SerializedType
 */
class SerializerMiddleware {
	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {DeserializedType} data data
<<<<<<< Updated upstream
	 * @param {object} context context object
	 * @returns {SerializedType|Promise<SerializedType>} serialized data
=======
	 * @param {Context} context context object
	 * @returns {SerializedType | Promise<SerializedType> | null} serialized data
>>>>>>> Stashed changes
	 */
	serialize(data, context) {
		const AbstractMethodError = require("../AbstractMethodError");
		throw new AbstractMethodError();
	}

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {SerializedType} data data
<<<<<<< Updated upstream
	 * @param {object} context context object
	 * @returns {DeserializedType|Promise<DeserializedType>} deserialized data
=======
	 * @param {Context} context context object
	 * @returns {DeserializedType | Promise<DeserializedType>} deserialized data
>>>>>>> Stashed changes
	 */
	deserialize(data, context) {
		const AbstractMethodError = require("../AbstractMethodError");
		throw new AbstractMethodError();
	}

	/**
<<<<<<< Updated upstream
	 * @param {any | function(): Promise<any> | any} value contained value or function to value
	 * @param {SerializerMiddleware<any, any>} target target middleware
	 * @param {object=} options lazy options
	 * @param {any=} serializedValue serialized value
	 * @returns {function(): Promise<any> | any} lazy function
	 */
	static createLazy(value, target, options = {}, serializedValue = undefined) {
		if (SerializerMiddleware.isLazy(value, target)) return value;
		const fn = typeof value === "function" ? value : () => value;
		fn[LAZY_TARGET] = target;
		/** @type {any} */ (fn).options = options;
=======
	 * @template LazyResult
	 * @param {LazyFunction<LazyResult> | EXPECTED_ANY} value contained value or function to value
	 * @param {SerializerMiddleware<any, any>} target target middleware
	 * @param {LazyOptions=} options lazy options
	 * @param {any=} serializedValue serialized value
	 * @returns {LazyFunction<LazyResult>} lazy function
	 */
	static createLazy(value, target, options = {}, serializedValue = undefined) {
		if (SerializerMiddleware.isLazy(value, target)) return value;
		const fn =
			/** @type {LazyFunction<LazyResult>} */
			(typeof value === "function" ? value : () => value);
		fn[LAZY_TARGET] = target;
		fn.options = options;
>>>>>>> Stashed changes
		fn[LAZY_SERIALIZED_VALUE] = serializedValue;
		return fn;
	}

	/**
<<<<<<< Updated upstream
	 * @param {function(): Promise<any> | any} fn lazy function
=======
	 * @param {EXPECTED_ANY} fn lazy function
>>>>>>> Stashed changes
	 * @param {SerializerMiddleware<any, any>=} target target middleware
	 * @returns {boolean} true, when fn is a lazy function (optionally of that target)
	 */
	static isLazy(fn, target) {
		if (typeof fn !== "function") return false;
		const t = fn[LAZY_TARGET];
		return target ? t === target : Boolean(t);
	}

	/**
<<<<<<< Updated upstream
	 * @param {function(): Promise<any> | any} fn lazy function
	 * @returns {object | undefined} options
=======
	 * @template LazyResult
	 * @param {LazyFunction<LazyResult>} fn lazy function
	 * @returns {LazyOptions | undefined} options
>>>>>>> Stashed changes
	 */
	static getLazyOptions(fn) {
		if (typeof fn !== "function") return;
		return /** @type {any} */ (fn).options;
	}

	/**
<<<<<<< Updated upstream
	 * @param {function(): Promise<any> | any} fn lazy function
=======
	 * @template LazyResult
	 * @param {LazyFunction<LazyResult> | EXPECTED_ANY} fn lazy function
>>>>>>> Stashed changes
	 * @returns {any | undefined} serialized value
	 */
	static getLazySerializedValue(fn) {
		if (typeof fn !== "function") return;
		return fn[LAZY_SERIALIZED_VALUE];
	}

	/**
<<<<<<< Updated upstream
	 * @param {function(): Promise<any> | any} fn lazy function
	 * @param {any} value serialized value
=======
	 * @template LazyResult
	 * @param {LazyFunction<LazyResult>} fn lazy function
	 * @param {TODO} value serialized value
>>>>>>> Stashed changes
	 * @returns {void}
	 */
	static setLazySerializedValue(fn, value) {
		fn[LAZY_SERIALIZED_VALUE] = value;
	}

	/**
<<<<<<< Updated upstream
	 * @param {function(): Promise<any> | any} lazy lazy function
	 * @param {function(any): Promise<any> | any} serialize serialize function
	 * @returns {function(): Promise<any> | any} new lazy
	 */
	static serializeLazy(lazy, serialize) {
		const fn = memoize(() => {
			const r = lazy();
			if (r && typeof r.then === "function") {
				return r.then(data => data && serialize(data));
			}
			return serialize(r);
		});
		fn[LAZY_TARGET] = lazy[LAZY_TARGET];
		/** @type {any} */ (fn).options = /** @type {any} */ (lazy).options;
=======
	 * @template LazyResult, R
	 * @param {LazyFunction<LazyResult>} lazy lazy function
	 * @param {(lazyResult: LazyResult) => Promise<R> | R} serialize serialize function
	 * @returns {LazyFunction<R>} new lazy
	 */
	static serializeLazy(lazy, serialize) {
		const fn = /** @type {LazyFunction<R>} */ (
			memoize(() => {
				const r = lazy();
				if (
					r &&
					typeof (/** @type {Promise<LazyResult>} */ (r).then) === "function"
				) {
					return (
						/** @type {Promise<LazyResult>} */
						(r).then(data => data && serialize(data))
					);
				}
				return serialize(/** @type {LazyResult} */ (r));
			})
		);
		fn[LAZY_TARGET] = lazy[LAZY_TARGET];
		fn.options = lazy.options;
>>>>>>> Stashed changes
		lazy[LAZY_SERIALIZED_VALUE] = fn;
		return fn;
	}

	/**
<<<<<<< Updated upstream
	 * @template T
	 * @param {function(): Promise<any> | any} lazy lazy function
	 * @param {function(T): Promise<T> | T} deserialize deserialize function
	 * @returns {function(): Promise<T> | T} new lazy
	 */
	static deserializeLazy(lazy, deserialize) {
		const fn = memoize(() => {
			const r = lazy();
			if (r && typeof r.then === "function") {
				return r.then(data => deserialize(data));
			}
			return deserialize(r);
		});
		fn[LAZY_TARGET] = lazy[LAZY_TARGET];
		/** @type {any} */ (fn).options = /** @type {any} */ (lazy).options;
=======
	 * @template LazyResult, R
	 * @param {LazyFunction<LazyResult>} lazy lazy function
	 * @param {(lazyResult: LazyResult) => Promise<R> | R} deserialize deserialize function
	 * @returns {LazyFunction<R>} new lazy
	 */
	static deserializeLazy(lazy, deserialize) {
		const fn = /** @type {LazyFunction<R>} */ (
			memoize(() => {
				const r = lazy();
				if (
					r &&
					typeof (/** @type {Promise<LazyResult>} */ (r).then) === "function"
				) {
					return (
						/** @type {Promise<LazyResult>} */
						(r).then(data => deserialize(data))
					);
				}
				return deserialize(/** @type {LazyResult} */ (r));
			})
		);
		fn[LAZY_TARGET] = lazy[LAZY_TARGET];
		fn.options = lazy.options;
>>>>>>> Stashed changes
		fn[LAZY_SERIALIZED_VALUE] = lazy;
		return fn;
	}

	/**
<<<<<<< Updated upstream
	 * @param {function(): Promise<any> | any} lazy lazy function
	 * @returns {function(): Promise<any> | any} new lazy
	 */
	static unMemoizeLazy(lazy) {
		if (!SerializerMiddleware.isLazy(lazy)) return lazy;
=======
	 * @template LazyResult
	 * @param {LazyFunction<LazyResult> | EXPECTED_ANY} lazy lazy function
	 * @returns {LazyFunction<LazyResult> | EXPECTED_ANY} new lazy
	 */
	static unMemoizeLazy(lazy) {
		if (!SerializerMiddleware.isLazy(lazy)) return lazy;
		/** @type {LazyFunction<LazyResult>} */
>>>>>>> Stashed changes
		const fn = () => {
			throw new Error(
				"A lazy value that has been unmemorized can't be called again"
			);
		};
		fn[LAZY_SERIALIZED_VALUE] = SerializerMiddleware.unMemoizeLazy(
			lazy[LAZY_SERIALIZED_VALUE]
		);
		fn[LAZY_TARGET] = lazy[LAZY_TARGET];
<<<<<<< Updated upstream
		fn.options = /** @type {any} */ (lazy).options;
=======
		fn.options = lazy.options;
>>>>>>> Stashed changes
		return fn;
	}
}

module.exports = SerializerMiddleware;
