/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

<<<<<<< Updated upstream
=======
/** @typedef {import("./SerializerMiddleware").Context} Context */

>>>>>>> Stashed changes
/**
 * @template T, K
 * @typedef {import("./SerializerMiddleware")<T, K>} SerializerMiddleware
 */

class Serializer {
	/**
	 * @param {SerializerMiddleware<any, any>[]} middlewares serializer middlewares
<<<<<<< Updated upstream
	 * @param {TODO=} context context
=======
	 * @param {Context} [context] context
>>>>>>> Stashed changes
	 */
	constructor(middlewares, context) {
		this.serializeMiddlewares = middlewares.slice();
		this.deserializeMiddlewares = middlewares.slice().reverse();
		this.context = context;
	}

	/**
<<<<<<< Updated upstream
	 * @param {any} obj object
	 * @param {TODO} context content
	 * @returns {Promise<any>} result
=======
	 * @param {TODO | Promise<TODO>} obj object
	 * @param {Context} context context object
	 * @returns {Promise<TODO>} result
>>>>>>> Stashed changes
	 */
	serialize(obj, context) {
		const ctx = { ...context, ...this.context };
		let current = obj;
		for (const middleware of this.serializeMiddlewares) {
			if (current && typeof current.then === "function") {
<<<<<<< Updated upstream
				current = current.then(data => data && middleware.serialize(data, ctx));
=======
				current =
					/** @type {Promise<TODO>} */
					(current).then(data => data && middleware.serialize(data, ctx));
>>>>>>> Stashed changes
			} else if (current) {
				try {
					current = middleware.serialize(current, ctx);
				} catch (err) {
					current = Promise.reject(err);
				}
			} else break;
		}
		return current;
	}

	/**
<<<<<<< Updated upstream
	 * @param {any} value value
	 * @param {TODO} context context
	 * @returns {Promise<any>} result
	 */
	deserialize(value, context) {
		const ctx = { ...context, ...this.context };
		/** @type {any} */
=======
	 * @param {TODO | Promise<TODO>} value value
	 * @param {Context} context object
	 * @returns {Promise<TODO>} result
	 */
	deserialize(value, context) {
		const ctx = { ...context, ...this.context };
>>>>>>> Stashed changes
		let current = value;
		for (const middleware of this.deserializeMiddlewares) {
			current =
				current && typeof current.then === "function"
<<<<<<< Updated upstream
					? current.then(data => middleware.deserialize(data, ctx))
=======
					? /** @type {Promise<TODO>} */ (current).then(data =>
							middleware.deserialize(data, ctx)
						)
>>>>>>> Stashed changes
					: middleware.deserialize(current, ctx);
		}
		return current;
	}
}

module.exports = Serializer;
